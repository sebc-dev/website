# GitHub Actions Workflow for Deployment to Cloudflare Workers
#
# Purpose:
# This workflow automates the deployment of the Next.js application to Cloudflare Workers.
# It serves as the final stage in the CI/CD pipeline after all quality checks pass.
#
# Triggers:
# - Manual dispatch (workflow_dispatch) for on-demand deployments
# - Automatic trigger after successful quality checks (workflow_run)
#
# Phases:
# 1. Structure (Commit 1): Workflow file setup with permissions and concurrency
# 2. Triggers (Commit 2): Add workflow_dispatch and workflow_run triggers
# 3. Deployment (Commit 3): Configure Cloudflare Workers deployment
# 4. Verification (Commit 4): Add post-deployment health checks
# 5. Logging (Commit 5): Add deployment artifacts and summary

name: Deploy to Cloudflare Workers

# ============================================================================
# Triggers Configuration (Commit 2)
# ============================================================================
#
# This workflow supports two trigger mechanisms:
#
# 1. Manual Deployment (workflow_dispatch)
#    - Allows developers to trigger deployments on-demand
#    - Optional inputs for skip_verification and dry_run
#    - Useful for emergency deployments or testing
#
# 2. Automatic Deployment (workflow_run)
#    - Triggers after quality checks pass successfully
#    - Limited to main/develop branches to avoid deploying feature branches
#    - Ensures code quality before production deployment
#    - Dependency: quality workflow must complete successfully
#
on:
  workflow_dispatch:
    inputs:
      skip_verification:
        description: 'Skip health check verification after deployment (use with caution)'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Run deployment steps without actually deploying (for testing)'
        required: false
        type: boolean
        default: false

  workflow_run:
    workflows: ['Quality Checks']
    types: [completed]
    branches:
      - main
      - develop

permissions:
  contents: read

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  DEPLOYMENT_TIMEOUT: 15m

jobs:
  # ============================================================================
  # Check workflow trigger status (Commit 2)
  # ============================================================================
  #
  # For workflow_run triggers: Only proceed if quality workflow succeeded
  # For manual triggers: Always proceed
  #
  check-trigger:
    name: Validate Workflow Trigger
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      should-deploy: ${{ steps.trigger-check.outputs.should-deploy }}
      trigger-type: ${{ steps.trigger-check.outputs.trigger-type }}

    steps:
      - name: Check trigger type
        id: trigger-check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "trigger-type=manual" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Trigger Type: Manual Deployment (workflow_dispatch)"
            echo "Skip Verification: ${{ github.event.inputs.skip_verification }}"
            echo "Dry Run: ${{ github.event.inputs.dry_run }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
              echo "trigger-type=automatic" >> $GITHUB_OUTPUT
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "Trigger Type: Automatic Deployment (workflow_run)"
              echo "Quality workflow completed successfully on branch: ${{ github.event.workflow_run.head_branch }}"
            else
              echo "trigger-type=automatic" >> $GITHUB_OUTPUT
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "Quality workflow failed. Deployment will not proceed."
            fi
          else
            echo "trigger-type=unknown" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Deployment Job (Commit 3: Cloudflare Workers Deployment)
  # ============================================================================
  #
  # This job handles the complete deployment process:
  # 1. Checkout code
  # 2. Setup environment (pnpm, Node.js)
  # 3. Install dependencies with locked versions
  # 4. Build the application (OpenNext adapter for Cloudflare Workers)
  # 5. Deploy to Cloudflare Workers using wrangler-action
  #
  # Environment Protection:
  # - Uses GitHub Environment "production" with required reviewers
  # - Manual approval required before deployment proceeds
  # - Environment-specific secrets (CLOUDFLARE_API_TOKEN, CLOUDFLARE_ACCOUNT_ID)
  # - Secrets are isolated per environment for security
  #
  # Security: Uses environment secrets with approval gate
  # Timeout: 10 minutes to prevent hanging deployments
  #
  deploy:
    name: Deploy to Cloudflare Workers
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    needs: check-trigger
    if: needs.check-trigger.outputs.should-deploy == 'true'
    environment: production

    steps:
      # ========================================================================
      # Step 1: Checkout Code
      # ========================================================================
      # Clone the repository at the commit being deployed
      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # Step 2: Setup pnpm
      # ========================================================================
      # Configure pnpm package manager
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '9.0.0'

      # ========================================================================
      # Step 3: Setup Node.js
      # ========================================================================
      # Install Node.js and configure pnpm cache
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'pnpm'

      # ========================================================================
      # Step 4: Install Dependencies
      # ========================================================================
      # Install dependencies with frozen lockfile to ensure reproducible builds
      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # ========================================================================
      # Step 5: Build Application
      # ========================================================================
      # Build Next.js application with OpenNext adapter for Cloudflare Workers
      # Output: .open-next/ directory containing the worker and assets
      - name: Build application
        run: pnpm build

      # ========================================================================
      # Step 5b: Generate OpenNext Cloudflare Adapter Output
      # ========================================================================
      # Explicitly run OpenNext Cloudflare adapter to generate .open-next/
      - name: Generate OpenNext output
        run: npx @opennextjs/cloudflare build

      # ========================================================================
      # Step 6: Deploy to Cloudflare Workers
      # ========================================================================
      # Deploy the built application to Cloudflare Workers using wrangler-action
      # Secrets are passed securely and not exposed in logs
      #
      # Action: cloudflare/wrangler-action@v3 (official Cloudflare action)
      # API Token: Required secret (CLOUDFLARE_API_TOKEN) with Workers Deploy permission
      # Account ID: Required secret (CLOUDFLARE_ACCOUNT_ID)
      # Worker Name: Required secret (CLOUDFLARE_WORKER_NAME) for environment-specific deployment
      # Command: wrangler deploy --name (deploys the worker from .open-next/)
      #
      - name: Deploy to Cloudflare Workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy --name ${{ secrets.CLOUDFLARE_WORKER_NAME }}

  # ============================================================================
  # Health Check Job (Commit 4: Post-Deployment Verification)
  # ============================================================================
  #
  # This job verifies that the deployed Worker is accessible and responds correctly.
  # It runs after the deployment completes successfully.
  #
  # Health Check Strategy:
  # - Target: Deployed Worker URL
  # - Method: HTTP GET request
  # - Success Criteria: HTTP 200 response
  # - Retry Logic: 3 attempts with 10-second delay between retries
  # - Purpose: Detect failed deployments (invalid code, missing dependencies, etc.)
  #
  # IMPORTANT: Rollback Procedure
  # If health check fails:
  # 1. Check Cloudflare Workers Dashboard for error logs
  # 2. Review recent deployments in Cloudflare UI
  # 3. Identify the failed deployment by timestamp
  # 4. Manually rollback to previous version using Cloudflare UI:
  #    - Go to Workers > Deploy History
  #    - Select the last successful deployment
  #    - Click "Rollback to this version"
  # 5. Investigate error logs to fix the issue
  # 6. Re-deploy with corrections
  #
  verify-deployment:
    name: Verify Deployment Health
    runs-on: ubuntu-latest
    permissions:
      contents: read
    needs: deploy
    outputs:
      worker-url: ${{ steps.worker-url.outputs.worker-url }}
    if: |
      needs.deploy.result == 'success' &&
      github.event.inputs.skip_verification != 'true'

    steps:
      # ========================================================================
      # Step 1: Checkout Code
      # ========================================================================
      # Clone the repository at the commit being deployed
      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # Step 2: Construct and Validate Worker URL
      # ========================================================================
      # Uses centralized script to:
      # - Validate CLOUDFLARE_WORKER_NAME is configured
      # - Extract worker name from wrangler.jsonc
      # - Verify strict name consistency (GitHub Secret matches wrangler.jsonc)
      # - Construct the Worker URL
      # - Provide clear error messages for troubleshooting
      #
      - name: Construct and Validate Worker URL
        id: worker-url
        env:
          CLOUDFLARE_WORKER_NAME: ${{ secrets.CLOUDFLARE_WORKER_NAME }}
          CLOUDFLARE_ACCOUNT_SUBDOMAIN: ${{ secrets.CLOUDFLARE_ACCOUNT_SUBDOMAIN }}
        run: |
          if [ -z "$CLOUDFLARE_ACCOUNT_SUBDOMAIN" ]; then
            echo "❌ ERROR: CLOUDFLARE_ACCOUNT_SUBDOMAIN not configured as environment secret"
            exit 1
          fi
          bash scripts/build-worker-url.sh

      # ========================================================================
      # Step 3: Health Check with Retry Logic
      # ========================================================================
      # Test HTTP endpoint with retries to account for CDN propagation delays
      #
      # Retry Strategy:
      # - Attempt 1: Immediate (DNS/CDN cache may not be updated yet)
      # - Delay 10s (allow for CDN propagation)
      # - Attempt 2: After 10 second delay
      # - Delay 10s
      # - Attempt 3: After another 10 second delay
      #
      # Success: HTTP 200 response received
      # Failure: All 3 attempts fail → workflow fails
      #
      - name: Execute Health Check
        id: health-check
        continue-on-error: true
        run: |
          WORKER_URL="${{ steps.worker-url.outputs.worker-url }}"
          MAX_ATTEMPTS=3
          RETRY_DELAY=10

          echo "Starting health check for Worker: ${WORKER_URL}"

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo ""
            echo "Health Check Attempt $attempt/$MAX_ATTEMPTS"
            echo "============================================"

            # Execute health check with 10-second timeout per request
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${WORKER_URL}")

            echo "HTTP Response Code: $HTTP_CODE"

            if [[ "$HTTP_CODE" == "200" ]]; then
              echo "✓ Health check PASSED - Worker is accessible"
              echo "health-status=success" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "✗ Health check FAILED - HTTP $HTTP_CODE received"

              # Only sleep between attempts (not after the last one)
              if [[ $attempt -lt $MAX_ATTEMPTS ]]; then
                echo "Waiting $RETRY_DELAY seconds before next attempt..."
                sleep $RETRY_DELAY
              fi
            fi
          done

          # All attempts failed
          echo ""
          echo "ERROR: All $MAX_ATTEMPTS health check attempts failed!"
          echo "The deployed Worker is not responding correctly."
          echo ""
          echo "health-status=failure" >> $GITHUB_OUTPUT
          exit 1

      # ========================================================================
      # Step 2b: Validate Health Check Status
      # ========================================================================
      # Explicitly check health status and fail the job if verification failed
      # This is necessary because health-check has continue-on-error: true
      #
      - name: Validate Health Check Result
        if: always()
        run: |
          HEALTH_STATUS="${{ steps.health-check.outputs.health-status }}"

          if [[ "$HEALTH_STATUS" != "success" ]]; then
            echo "❌ Health check verification failed"
            exit 1
          fi

      # ========================================================================
      # Step 3: Report Health Check Result
      # ========================================================================
      # Set workflow output based on health check result
      # This output is available for GitHub deployments and notifications
      #
      - name: Report Deployment Status
        if: always()
        run: |
          if [[ "${{ steps.health-check.outputs.health-status }}" == "success" ]]; then
            echo "✓ Deployment verification PASSED"
            echo "Worker is accessible and responding to requests"
            echo "Deployment completed successfully!"
          else
            echo "✗ Deployment verification FAILED"
            echo "Worker health check did not receive HTTP 200 response"
            echo ""
            echo "To rollback:"
            echo "1. Visit Cloudflare Dashboard → Workers → [Worker Name]"
            echo "2. Go to 'Deploy History'"
            echo "3. Find the last successful deployment"
            echo "4. Click 'Rollback to this version'"
            exit 1
          fi

      # ========================================================================
      # Step 4: Skip Verification Message (if skipped)
      # ========================================================================
      # Inform user when health check verification is intentionally skipped
      # (This step only runs if skip_verification was set to true)
      #
      - name: Note Verification Skipped
        if: |
          always() &&
          github.event.inputs.skip_verification == 'true'
        run: |
          echo "⚠ Health check verification was SKIPPED"
          echo "Skip Verification input: ${{ github.event.inputs.skip_verification }}"
          echo ""
          echo "IMPORTANT: Verify deployment manually!"
          echo "Check: ${{ steps.worker-url.outputs.worker-url }}"

  # ============================================================================
  # Deployment Logging Job (Commit 5: Logging and Artifact Upload)
  # ============================================================================
  #
  # This job captures deployment information and creates workflow artifacts:
  # - Deployment summary (URL, timestamp, commit SHA)
  # - Deployment logs for debugging
  # - Deployment metrics (duration, build details)
  # - GitHub environment tracking
  #
  # Artifacts are retained for 14 days for audit and troubleshooting purposes
  #
  deployment-logging:
    name: Create Deployment Artifacts and Summary
    runs-on: ubuntu-latest
    needs: [deploy, verify-deployment]
    permissions:
      contents: read
      deployments: write
    if: always()

    steps:
      # ========================================================================
      # Step 1: Prepare Deployment Summary
      # ========================================================================
      # Generate deployment summary with key information for logging and tracking
      #
      - name: Generate Deployment Summary
        id: deployment-summary
        run: |
          # Capture deployment information
          DEPLOYMENT_TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          COMMIT_SHA="${{ github.sha }}"
          COMMIT_SHA_SHORT="${COMMIT_SHA:0:7}"
          GITHUB_RUN_ID="${{ github.run_id }}"
          GITHUB_RUN_NUMBER="${{ github.run_number }}"
          TRIGGER_TYPE="${{ github.event_name }}"
          BRANCH_NAME="${{ github.ref_name }}"
          ACTOR="${{ github.actor }}"

          # Determine Worker URL based on deployment status
          # If verify-deployment succeeded, use its output; otherwise, construct from worker name
          VERIFY_JOB_RESULT="${{ needs.verify-deployment.result }}"
          if [[ "$VERIFY_JOB_RESULT" == "success" ]]; then
            WORKER_URL="${{ needs.verify-deployment.outputs.worker-url }}"
          else
            # Fallback: Use centralized script to construct Worker URL for skipped verification
            # This ensures consistency and validates worker name configuration
            export CLOUDFLARE_WORKER_NAME="${{ secrets.CLOUDFLARE_WORKER_NAME }}"
            WORKER_URL=$(bash scripts/build-worker-url.sh 2>/dev/null || echo "[Worker URL construction failed]")
          fi

          # Save summary as environment variable and output for reuse
          echo "worker-url=${WORKER_URL}" >> $GITHUB_OUTPUT
          echo "deployment-timestamp=${DEPLOYMENT_TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "commit-sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT
          echo "commit-sha-short=${COMMIT_SHA_SHORT}" >> $GITHUB_OUTPUT
          echo "github-run-id=${GITHUB_RUN_ID}" >> $GITHUB_OUTPUT
          echo "github-run-number=${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
          echo "trigger-type=${TRIGGER_TYPE}" >> $GITHUB_OUTPUT
          echo "branch-name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "actor=${ACTOR}" >> $GITHUB_OUTPUT

          echo "Deployment Summary Generated:"
          echo "  Worker URL: ${WORKER_URL}"
          echo "  Timestamp: ${DEPLOYMENT_TIMESTAMP}"
          echo "  Commit SHA: ${COMMIT_SHA}"
          echo "  Run ID: ${GITHUB_RUN_ID}"
          echo "  Trigger: ${TRIGGER_TYPE}"
          echo "  Branch: ${BRANCH_NAME}"
          echo "  Actor: ${ACTOR}"

      # ========================================================================
      # Step 2: Create Deployment Logs Archive
      # ========================================================================
      # Create a structured log file with deployment details for artifact upload
      # This provides a permanent record of each deployment for auditing
      #
      - name: Create Deployment Logs
        id: create-logs
        run: |
          LOGS_DIR="deployment-logs"
          mkdir -p "${LOGS_DIR}"

          DEPLOYMENT_TIMESTAMP="${{ steps.deployment-summary.outputs.deployment-timestamp }}"
          # Replace colons with dashes for artifact-compatible filename
          LOG_TIMESTAMP=$(echo "${DEPLOYMENT_TIMESTAMP}" | tr ':' '-')
          LOG_FILENAME="deployment-${LOG_TIMESTAMP}.log"
          LOG_FILE="${LOGS_DIR}/${LOG_FILENAME}"

          # Create comprehensive deployment log file
          cat > "${LOG_FILE}" << 'EOF'
          ======================================================================
          CLOUDFLARE WORKERS DEPLOYMENT LOG
          ======================================================================

          DEPLOYMENT METADATA
          -------------------
          Timestamp:          ${{ steps.deployment-summary.outputs.deployment-timestamp }}
          Worker URL:         ${{ steps.deployment-summary.outputs.worker-url }}
          Commit SHA:         ${{ steps.deployment-summary.outputs.commit-sha }}
          Commit SHA Short:   ${{ steps.deployment-summary.outputs.commit-sha-short }}
          GitHub Run ID:      ${{ steps.deployment-summary.outputs.github-run-id }}
          GitHub Run Number:  ${{ steps.deployment-summary.outputs.github-run-number }}
          Trigger Type:       ${{ steps.deployment-summary.outputs.trigger-type }}
          Branch Name:        ${{ steps.deployment-summary.outputs.branch-name }}
          Actor:              ${{ steps.deployment-summary.outputs.actor }}

          DEPLOYMENT STATUS
          -----------------
          Deploy Job:         ${{ needs.deploy.result }}
          Verify Job:         ${{ needs.verify-deployment.result }}

          ENVIRONMENT INFORMATION
          ----------------------
          Node Version:       20.x
          pnpm Version:       9.0.0
          Build Tool:         Next.js with OpenNext
          Runtime:            Cloudflare Workers

          DEPLOYMENT NOTES
          ----------------
          - Deployment workflow executed successfully
          - See workflow run for complete logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - Worker accessible at: ${{ steps.deployment-summary.outputs.worker-url }}

          ======================================================================
          END OF DEPLOYMENT LOG
          ======================================================================
          EOF

          echo "logs-filename=${LOG_FILENAME}" >> $GITHUB_OUTPUT
          echo "logs-dir=${LOGS_DIR}" >> $GITHUB_OUTPUT

          echo "Deployment logs created: ${LOG_FILE}"
          cat "${LOG_FILE}"

      # ========================================================================
      # Step 3: Upload Deployment Artifacts
      # ========================================================================
      # Upload deployment logs as workflow artifacts for long-term retention
      # Artifacts are retained for 14 days by default for auditing purposes
      #
      - name: Upload Deployment Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs-${{ steps.deployment-summary.outputs.github-run-number }}
          path: deployment-logs/
          retention-days: 14
          if-no-files-found: warn

      # ========================================================================
      # Step 4: Create GitHub Job Summary
      # ========================================================================
      # Write deployment summary to GitHub job summary for visibility in UI
      # This is displayed in the Actions workflow UI and job summary
      #
      - name: Create Workflow Job Summary
        if: always()
        run: |
          {
            echo "# Deployment Complete"
            echo ""
            echo "## Deployment Information"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| **Worker URL** | [\`${{ steps.deployment-summary.outputs.worker-url }}\`](${{ steps.deployment-summary.outputs.worker-url }}) |"
            echo "| **Deployment Time** | \`${{ steps.deployment-summary.outputs.deployment-timestamp }}\` |"
            echo "| **Commit SHA** | \`${{ steps.deployment-summary.outputs.commit-sha-short }}\` |"
            echo "| **GitHub Run** | [${{ steps.deployment-summary.outputs.github-run-number }}](https://github.com/${{ github.repository }}/actions/runs/${{ steps.deployment-summary.outputs.github-run-id }}) |"
            echo "| **Branch** | \`${{ steps.deployment-summary.outputs.branch-name }}\` |"
            echo "| **Trigger** | \`${{ steps.deployment-summary.outputs.trigger-type }}\` |"
            echo ""
            echo "## Deployment Status"
            echo ""
            if [[ "${{ needs.deploy.result }}" == "success" ]]; then
              echo "✅ **Deployment Job**: SUCCESS"
            else
              echo "❌ **Deployment Job**: ${{ needs.deploy.result }}"
            fi
            echo ""
            if [[ "${{ needs.verify-deployment.result }}" == "success" ]]; then
              echo "✅ **Verification Job**: SUCCESS"
            else
              echo "⚠️  **Verification Job**: ${{ needs.verify-deployment.result }}"
            fi
            echo ""
            echo "## Next Steps"
            echo ""
            echo "1. Visit the deployed Worker: ${{ steps.deployment-summary.outputs.worker-url }}"
            echo "2. Run smoke tests to verify functionality"
            echo "3. Monitor Cloudflare Dashboard for any errors"
            echo "4. Deployment logs available in workflow artifacts"
          } >> $GITHUB_STEP_SUMMARY

      # ========================================================================
      # Step 5: Create GitHub Deployment Environment
      # ========================================================================
      # Track deployment in GitHub environments for visibility and auditing
      # Links the deployment to the 'production' environment
      #
      - name: Create GitHub Deployment
        if: needs.deploy.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Cloudflare Workers Production Deployment',
              required_contexts: [],
              auto_merge: false
            });

            console.log('Created deployment:', deployment.data.id);

            // Mark deployment as successful
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: '${{ steps.deployment-summary.outputs.worker-url }}',
              description: 'Deployment successful'
            });

            console.log('Deployment status updated to success');

      # ========================================================================
      # Step 6: Log Deployment Summary to Console
      # ========================================================================
      # Output final deployment summary for user reference
      #
      - name: Log Deployment Summary
        if: always()
        run: |
          echo ""
          echo "========================================================================"
          echo "DEPLOYMENT SUMMARY"
          echo "========================================================================"
          echo ""
          echo "✓ Worker URL: ${{ steps.deployment-summary.outputs.worker-url }}"
          echo "✓ Deployment Time: ${{ steps.deployment-summary.outputs.deployment-timestamp }}"
          echo "✓ Commit SHA: ${{ steps.deployment-summary.outputs.commit-sha-short }}"
          echo "✓ GitHub Run: ${{ github.run_id }}"
          echo ""
          echo "Deploy Status: ${{ needs.deploy.result }}"
          echo "Verify Status: ${{ needs.verify-deployment.result }}"
          echo ""
          echo "Artifacts: Available in Actions tab for 14 days"
          echo "Logs: ${{ steps.create-logs.outputs.logs-dir }}/${{ steps.create-logs.outputs.logs-filename }}"
          echo ""
          echo "========================================================================"
